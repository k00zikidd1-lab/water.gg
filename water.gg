local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local window = Library:CreateWindow({
    Title = "Water.GG",
    Footer = "https://discord.gg/R48ZT6XU7",
	Icon = 128319020082767,
    NotifySide = "Right",
    ShowCustomCursor = true
})

local tabs = {
    main = window:AddTab("Combat", "sword"),
    vis = window:AddTab("Visuals", "eye"),
    plr = window:AddTab("Movement", "user"),
    farm = window:AddTab("Farm", "star"),
    skin = window:AddTab("Skins", "palette")
}

local white = tabs.main:AddRightGroupbox("Whitelist")
local silent = tabs.main:AddLeftGroupbox("Silent Aim") 
local aim = tabs.main:AddRightGroupbox("Aimbot") 
local rage = tabs.main:AddLeftGroupbox("Ragebot")
local meele = tabs.main:AddRightGroupbox("Meele Aura") 
local esp = tabs.vis:AddLeftGroupbox("ESP") 
local esp2 = tabs.vis:AddRightGroupbox("ESP Scraps") 
local plrc = tabs.plr:AddLeftGroupbox("Player Changes")
local mod = tabs.main:AddRightGroupbox("Gun Mods")

local ESP = loadstring(game:HttpGet("https://pastebin.com/raw/2dU36TmL"))()
ESP.Enabled = false
ESP.ShowBox = false
ESP.ShowName = false
ESP.ShowHealth = false
ESP.ShowTracer = false
ESP.ShowDistance = false

ESP_Settings = {
    BoxOutlineColor = Color3.new(0, 0, 0),
    BoxColor = Color3.new(1, 1, 1),
    NameColor = Color3.new(1, 1, 1),
    HealthOutlineColor = Color3.new(0, 0, 0),
    HealthHighColor = Color3.new(0, 1, 0),
    HealthLowColor = Color3.new(1, 0, 0),
    TracerColor = Color3.new(1, 1, 1),
    TracerThickness = 2,
    TracerPosition = "Bottom"
}

local bones = loadstring(game:HttpGet("https://raw.githubusercontent.com/k00zikidd1-lab/water.gg/refs/heads/main/esp"))()
bones.Enabled = false
bones.ShowSkeletons = false

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()
local camera = workspace.CurrentCamera
local rp = game:GetService("ReplicatedStorage")
local plrs = Players
local me = Player
local Workspace = game:GetService("Workspace")

local Aiming = false
local Target = nil
local WhiteList = {}

local functions = {
    SilentAim = false,
	infiniteStamina = false,
    FastPickup = false,
    RageBot = false,
    InstantReload = false,
    AutoPickupScraps = false,
    AutoPickupTools = false,
    AutoPickupCrates = false,
    AutoPickupMoney = false,
    NoBarriers = false,
    AutoOpenDoors = false,
    FakeDown = false,
	CheckDowned = false,
    NoGrinder = false,
    AntiFling = false,
    HideHead = false,
    AdminCheck = false
}

local Settings = {
    InfiniteStamina = false,
    GunMods = {NoRecoil = false}
}

local SectionSettings = {
    SilentAim = {
        Draw = true,
        DrawSize = 130,
        DrawColor = Color3.new(1, 1, 1),
		    Thickness = 2,
        Transparency = 1,
        TargetParts = {"Head"},
        CheckDowned = false,
        CheckWall = false,
        CheckTeam = false,
        CheckWhiteList = false
    },
    RageBot = {
        CheckDowned = false,
        CheckWhiteList = false
    },
    ESP = {
        Highlight = false
    }
}

local cockie = {SilentAimCircle = nil}

silent:AddToggle("silent", {
	Text = "Silent Aim",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	    functions.SilentAim = Value
	    if Value then
          cockie.SilentAimCircle = Drawing.new("Circle")
          cockie.SilentAimCircle.Color = SectionSettings.SilentAim.DrawColor
          cockie.SilentAimCircle.Thickness = SectionSettings.SilentAim.Thickness
          cockie.SilentAimCircle.NumSides = 50
          cockie.SilentAimCircle.Radius = SectionSettings.SilentAim.DrawSize
          cockie.SilentAimCircle.Filled = false
          cockie.SilentAimCircle.Visible = SectionSettings.SilentAim.Draw
          cockie.SilentAimCircle.Position = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
          local target = nil
          local function GetClosest()
              target = nil
              local shortest = SectionSettings.SilentAim.DrawSize
              for _, a in pairs(plrs:GetPlayers()) do
                  if a ~= me and a.Character then
                      if SectionSettings.SilentAim.CheckDowned and CharStats(a).Downed.Value == true then continue end
                      if SectionSettings.SilentAim.CheckTeam and a.Team == me.Team then continue end
                      if SectionSettings.SilentAim.CheckWhiteList and table.find(WhiteList, a) then continue end
                      local hrp = a.Character:FindFirstChild("HumanoidRootPart")
                      if hrp then
                          local screenpos, onScreen = camera:WorldToViewportPoint(hrp.Position)
                          if onScreen then
                              local dist = (Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2) - Vector2.new(screenpos.X, screenpos.Y)).Magnitude
                              if dist < shortest then
                                  target = a
                                  shortest = dist
                              end
                          end
                      end
                  end
              end
          end
          getgenv().SilentAimRenderConn = RunService.RenderStepped:Connect(GetClosest)
          local VisualizeEvent = rp.Events2.Visualize
          local DamageEvent = rp.Events["ZFKLF__H"]
          getgenv().SilentAimVisualizeConn = VisualizeEvent.Event:Connect(function(_, ShotCode, _, Gun, _, StartPos, BulletsPerShot)
              if not functions.SilentAim then return end
              if not Gun or not target or not target.Character or not target.Character:FindFirstChild("Humanoid") or target.Character:FindFirstChild("Humanoid").Health == 0 then return end
              if not me.Character or not me.Character:FindFirstChildOfClass("Tool") then return end
              local selectedPart = SectionSettings.SilentAim.TargetParts[1] or "Head"
              local targetPart = target.Character:FindFirstChild(selectedPart) or target.Character:FindFirstChild("Head")
              if not targetPart then return end
              local partPos = targetPart.Position
              local Bullets = {}
              for i = 1, math.clamp(#BulletsPerShot, 1, 100) do
                  table.insert(Bullets, CFrame.new(StartPos, partPos).LookVector)
              end
              task.wait(0.005)
              for i, dir in pairs(Bullets) do
                  DamageEvent:FireServer("üßà", Gun, ShotCode, i, targetPart, partPos, dir)
              end
              if Gun:FindFirstChild("Hitmarker") then
                  Gun.Hitmarker:Fire(targetPart)
              end
          end)
      else
          if cockie.SilentAimCircle then
              cockie.SilentAimCircle:Remove()
              cockie.SilentAimCircle = nil
          end
          if getgenv().SilentAimRenderConn then
              getgenv().SilentAimRenderConn:Disconnect()
          end
          if getgenv().SilentAimVisualizeConn then
              getgenv().SilentAimVisualizeConn:Disconnect()
          end
      end
	   end
})
:AddKeyPicker("silentkey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Silent Aim Key",
    NoUI = false,
})

silent:AddToggle("team", {
	Text = "Check Team",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    SectionSettings.SilentAim.CheckTeam = Value
    functions.CheckTeam = Value
end,
})

silent:AddToggle("down", {
	Text = "Check Downed",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    SectionSettings.SilentAim.CheckDowned = Value
    functions.CheckDowned = Value
end,
})


silent:AddToggle("whitelist", {
	Text = "Check Whitelist",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    SectionSettings.SilentAim.CheckWhitelist = Value
    functions.CheckWhitelist = Value
end,
})

esp:AddToggle("vis1", {
	Text = "Enabled ESP",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.Enabled = Value
end,
})

esp:AddToggle("vis2", {
	Text = "Show Box",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.ShowBox = Value
end,
})

esp:AddToggle("vis3", {
	Text = "Show Name",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.ShowName = Value
end,
})

esp:AddToggle("vis4", {
	Text = "Show Health",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.ShowHealth = Value
end,
})

esp:AddToggle("vis5", {
	Text = "Show Tracer",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.ShowTracer = Value
end,
})

esp:AddToggle("vis6", {
	Text = "Show Distance",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
    ESP.ShowDistance = Value
end,
})

esp:AddToggle("vis7", {
	Text = "Show Skeletons",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	bones.Enabled = Value
    bones.ShowSkeletons = Value
end,
})

esp:AddDivider()

plrc:AddToggle("fastpickup", {
	Text = "Fast Pickup",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	    functions.FastPickup = Value
	    if Value then
	        for _, obj in ipairs(game:GetDescendants()) do
	            if obj:IsA("ProximityPrompt") then
	                obj.HoldDuration = 0
	            end
	        end
	        getgenv().FastPickupConn = game.DescendantAdded:Connect(function(obj)
	            if obj:IsA("ProximityPrompt") then
	                obj.HoldDuration = 0
	                obj:GetPropertyChangedSignal("HoldDuration"):Connect(function()
	                    if functions.FastPickup then
	                        obj.HoldDuration = 0
	                    end
	                end)
	            end
	        end)
	    else
	        if getgenv().FastPickupConn then
	            getgenv().FastPickupConn:Disconnect()
	        end
	    end
	end,
})
:AddKeyPicker("fastpickupkey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Fast Pickup Key",
    NoUI = false,
})

plrc:AddToggle("autopickupmoney", {
	Text = "Auto Pickup Money",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	    functions.AutoPickupMoney = Value
	    if Value then
	        local remote = rp.Events:FindFirstChild("CZDPZUS")
	        local moneyfolder = workspace.Filter.SpawnedBread
	        local canPickup = true
	        local startTick = tick()
	        getgenv().AutoPickupMoneyConn = RunService.RenderStepped:Connect(function()
	            local function GetMoney()
	                local maxdist = 15
	                local closest = nil
	                for _, a in pairs(moneyfolder:GetChildren()) do
	                    if a and me.Character and me.Character.HumanoidRootPart then
	                        local getdist = (me.Character.HumanoidRootPart.Position - a.Position).Magnitude
	                        if getdist < maxdist then
	                            maxdist = getdist
	                            closest = a
	                        end
	                    end
	                end
	                maxdist = 15
	                return closest
	            end
	            local foundmoney = GetMoney()
	            if foundmoney then
	                if canPickup then
	                    remote:FireServer(foundmoney)
	                    canPickup = false
	                end
	            end
	            if canPickup == false and tick() - startTick >= 1 then
	                canPickup = true
	                startTick = tick()
	            end
	        end)
	    else
	        if getgenv().AutoPickupMoneyConn then
	            getgenv().AutoPickupMoneyConn:Disconnect()
	        end
	    end
	end,
})
:AddKeyPicker("autopickupmoneykey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Auto Pickup Money Key",
    NoUI = false,
})

plrc:AddToggle("autopickupcrates", {
	Text = "Auto Pickup Crates",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	    functions.AutoPickupCrates = Value
	    if Value then
	        local remote = rp.Events.PIC_CRATE
	        local cratesfolder = workspace.Filter.SpawnedCrates
	        local canPickup = true
	        local startTick = tick()
	        getgenv().AutoPickupCratesConn = RunService.RenderStepped:Connect(function()
	            local function GetClosestCrate()
	                local maxdist = 15
	                local closest = nil
	                for _, a in pairs(cratesfolder:GetChildren()) do
	                    if a and me.Character and me.Character.HumanoidRootPart then
	                        local handle = a:FindFirstChild("Handle")
	                        if handle and (handle:IsA("Part") or handle:IsA("MeshPart")) then
	                            local getdist = (me.Character.HumanoidRootPart.Position - handle.Position).Magnitude
	                            if getdist < maxdist then
	                                maxdist = getdist
	                                closest = a
	                            end
	                        end
	                    end
	                end
	                maxdist = 15
	                return closest
	            end
	            local crate = GetClosestCrate()
	            if crate then
	                local Handle = crate:FindFirstChild("Handle")
	                if Handle then
	                    if canPickup then
	                        remote:FireServer(Handle)
	                        canPickup = false
	                    end
	                end
	            end
	            if canPickup == false and tick() - startTick >= 1.5 then
	                canPickup = true
	                startTick = tick()
	            end
	        end)
	    else
	        if getgenv().AutoPickupCratesConn then
	            getgenv().AutoPickupCratesConn:Disconnect()
	        end
	    end
	end,
})
:AddKeyPicker("autopickupcrateskey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Auto Pickup Crates Key",
    NoUI = false,
})

silent:AddDropdown("aimp", {
	Values = { "Head", "Torso", "Left Leg", "Right Leg", "Left Arm", "Right Arm" },
	Default = 1, -- number index of the value / string
	Multi = false, -- true / false, allows multiple choices to be selected

	Text = "Silent Aim Parts",
	Tooltip = "This is a tooltip", -- Information shown when you hover over the dropdown
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the dropdown while it's disabled

	Searchable = false, -- true / false, makes the dropdown searchable (great for a long list of values)

	Callback = function(Value)
		SectionSettings.SilentAim.TargetParts = {Value}
	end,

	Disabled = false, -- Will disable the dropdown (true / false)
	Visible = true, -- Will make the dropdown invisible (true / false)
})

silent:AddDivider()

silent:AddSlider("fovc", {
	Text = "FOV Circle Change",
	Default = 80,
	Min = 1,
	Max = 200,
	Rounding = 1,
	Compact = false,

	Callback = function(Value)
		SectionSettings.SilentAim.DrawSize = Value
	end,

	Tooltip = "I am a slider!", -- Information shown when you hover over the slider
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the slider while it's disabled

	Disabled = false, -- Will disable the slider (true / false)
	Visible = true, -- Will make the slider invisible (true / false)
})


mod:AddToggle("nor", {
    Text = "No Recoil",
    Tooltip = "This is a tooltip",
    DisabledTooltip = "I am disabled!",

    Default = false,
    Disabled = false,
    Visible = true,
    Risky = false,

    Callback = function(Value)
        Settings.GunMods.NoRecoil = Value

        if Value then
            local lp = game:GetService("Players").LocalPlayer
            local lpc = lp.Character

            local norecoilConnect = lpc.ChildAdded:Connect(function(Item)
                if Item:IsA("Tool") then
                    for i, v in pairs(getgc(true)) do
                        if type(v) == "table" and rawget(v, "EquipTime") then
                            v.Recoil = 0
                            v.CameraRecoilingEnabled = false
                            v.AngleX_Min = 0
                            v.AngleX_Max = 0
                            v.AngleY_Min = 0
                            v.AngleY_Max = 0
                            v.AngleZ_Min = 0
                            v.AngleZ_Max = 0
                        end
                    end
                end
            end)

            getgenv().norecoilConn = norecoilConnect
        end
    end
})

-- Melee Aura core (defina antes da UI toggle)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local plrs = Players
local me = plrs.LocalPlayer
local run = RunService
local eventsFolder = ReplicatedStorage:WaitForChild("Events")

local remoteFunctionPath = "XMHH.2"  -- ajuste se necess√°rio
local remoteEventPath = "XMHH2.2"    -- ajuste se necess√°rio

local remote1 = eventsFolder:WaitForChild(remoteFunctionPath) -- RemoteFunction esperado
local remote2 = eventsFolder:WaitForChild(remoteEventPath)    -- RemoteEvent esperado

local maxdist = 5

local MeleeAura_Enabled = false
local MeleeAura_Connection

local function MeleeAura_Disable()
    MeleeAura_Enabled = false
    if MeleeAura_Connection and MeleeAura_Connection.Connected then
        MeleeAura_Connection:Disconnect()
    end
    MeleeAura_Connection = nil
end

local function Attack(target)
    if not (target and target:FindFirstChild("Head")) then return end

    local char = me.Character
    local tool = char and char:FindFirstChildOfClass("Tool")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")

    if not remote1 or not remote1:IsA("RemoteFunction") then
        warn("MeleeAura Error: RemoteFunction not found or wrong type at: " .. remoteFunctionPath)
        MeleeAura_Disable()
        return
    end
    if not remote2 or not remote2:IsA("RemoteEvent") then
        warn("MeleeAura Error: RemoteEvent not found or wrong type at: " .. remoteEventPath)
        MeleeAura_Disable()
        return
    end

    local arg1 = {
        [1] = "üçû",
        [2] = tick(),
        [3] = tool,
        [4] = "43TRFWX",
        [5] = "Normal",
        [6] = tick(),
        [7] = true
    }

    local success1, result = pcall(function()
        return remote1:InvokeServer(unpack(arg1))
    end)

    if not success1 then
        warn("MeleeAura Error: InvokeServer failed:", result)
        return
    end

    task.wait(0.1)

    local Handle = tool and (tool:FindFirstChild("WeaponHandle") or tool:FindFirstChild("Handle")) or (char and char:FindFirstChild("Right Arm"))
    local head = target:FindFirstChild("Head")

    if Handle and head and hrp then
        local arg2 = {
            [1] = "üçû",
            [2] = tick(),
            [3] = tool,
            [4] = "2389ZFX34",
            [5] = result,
            [6] = false,
            [7] = Handle,
            [8] = head,
            [9] = target,
            [10] = hrp.Position,
            [11] = head.Position
        }

        local success2, err2 = pcall(function()
            remote2:FireServer(unpack(arg2))
        end)
        if not success2 then
            warn("MeleeAura Error: FireServer failed:", err2)
        end
    end
end

local function runAttackLoop()
    return run.RenderStepped:Connect(function()
        if not MeleeAura_Enabled then return end
        local char = me.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp then
            for _, plr in ipairs(plrs:GetPlayers()) do
                if plr ~= me then
                    local c = plr.Character
                    local hrp2 = c and c:FindFirstChild("HumanoidRootPart")
                    local hum = c and c:FindFirstChildOfClass("Humanoid")
                    if hrp2 and hum then
                        local dist = (hrp.Position - hrp2.Position).Magnitude
                        if dist < maxdist and hum.Health > 15 and not c:FindFirstChildOfClass("ForceField") then
                            Attack(c)
                        end
                    end
                end
            end
        end
    end)
end

local function MeleeAura_Enable()
    if MeleeAura_Enabled then return end
    MeleeAura_Enabled = true
    if MeleeAura_Connection and MeleeAura_Connection.Connected then
        MeleeAura_Connection:Disconnect()
    end
    MeleeAura_Connection = runAttackLoop()
end

-- UI Toggle (chame isso onde cria sua UI)
meele:AddToggle("meele", {
    Text = "Meele Aura",
    Tooltip = "This is a tooltip",
    DisabledTooltip = "I am disabled!",

    Default = false,
    Disabled = false,
    Visible = true,
    Risky = false,

    Callback = function(Value)
        -- armazena estado em functions (se voc√™ usa essa tabela)
        functions.meeleaura = Value

        if Value then
            MeleeAura_Enable()
        else
            MeleeAura_Disable()
        end
    end,
}):AddKeyPicker("nofalldmg", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Meele aura Key",
    NoUI = false,
})

local oldStamina

plrc:AddToggle("inf", {
    Text = "Infinite Stamina",
    Tooltip = "This is a tooltip",
    DisabledTooltip = "I am disabled!",
    Default = false,
    Disabled = false,
    Visible = true,
    Risky = false,

    Callback = function(Value)
        functions.infstamina = Value

        if Value then
            if not oldStamina then
                oldStamina = hookfunction(getupvalue(getrenv()._G.S_Take, 2), function(v1, ...)
                    if functions.infstamina then
                        v1 = 0
                    end
                    return oldStamina(v1, ...)
                end)
            end
        else
            if oldStamina then
                hookfunction(getupvalue(getrenv()._G.S_Take, 2), oldStamina)
                oldStamina = nil
            end
        end
    end
})
:AddKeyPicker("infkey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Infinite Stamina Key",
    NoUI = false,
})

silent:AddSlider("fovt", {
	Text = "FOV Circle Thickness",
	Default = 2,
	Min = 1,
	Max = 10,
	Rounding = 1,
	Compact = false,

	Callback = function(Value)
		SectionSettings.SilentAim.Thickness = Value
	end,

	Tooltip = "I am a slider!", -- Information shown when you hover over the slider
	DisabledTooltip = "I am disabled!", -- Information shown when you hover over the slider while it's disabled

	Disabled = false, -- Will disable the slider (true / false)
	Visible = true, -- Will make the slider invisible (true / false)
})

plrc:AddToggle("nof", {
	Text = "No Fall Damage",
	Tooltip = "This is a tooltip",
	DisabledTooltip = "I am disabled!",

	Default = false,
	Disabled = false,
	Visible = true,
	Risky = false,

	Callback = function(Value)
	    functions.nofalldmg = Value
	    if functions.nofalldmg then
	        local plrs = game:GetService("Players")
	        local me = plrs.LocalPlayer
	        if me.Character then
	            local ff = Instance.new("ForceField")
	            ff.Parent = me.Character
	            ff.Visible = false
	        end
	        me.CharacterAdded:Connect(function(char)
	            if functions.nofalldmg and char and char:WaitForChild("HumanoidRootPart") and char:WaitForChild("Humanoid") then
	                local ff = Instance.new("ForceField")
	                ff.Parent = char
	                ff.Visible = false
	            end
	        end)
	    else
	        for _, a in pairs(me.Character:GetChildren()) do
	            if a:IsA("ForceField") and a.Visible == false then
	                a:Destroy()
	            end
	        end
	    end
end,
})
:AddKeyPicker("nofalldmg", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "No fall damage Key",
    NoUI = false,
})

-- === Invisibility core (mais resistente a erros) ===
local cloneref = cloneref or function(...) return ... end
local Service = setmetatable({}, {
    __index = function(_, k) return cloneref(game:GetService(k)) end
})

-- espera o jogo e o LocalPlayer
repeat task.wait() until game:IsLoaded()
local Players = Service.Players
local Player = Players and Players.LocalPlayer
repeat task.wait() Player = Players and Players.LocalPlayer until Player

-- refer√™ncias do personagem (garante exist√™ncia)
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid, HumanoidRootPart
local function UpdateCharacterReferences()
    Character = Player.Character
    if Character then
        HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        Humanoid = Character:FindFirstChildOfClass("Humanoid")
    else
        HumanoidRootPart = nil
        Humanoid = nil
    end
end
UpdateCharacterReferences()

local Invis_Fixed = true
local InvisEnabled = false
local Track = nil
local Animation = Instance.new("Animation")
Animation.AnimationId = "rbxassetid://215384594"

local RunService = Service.RunService
local Heartbeat = RunService and RunService.Heartbeat
local RenderStepped = RunService and RunService.RenderStepped
local StarterGui = Service.StarterGui
local CoreGui = Service.CoreGui

-- GUI aviso
local GUI = Instance.new("ScreenGui")
GUI.Name = "InvisWarningGUI"
GUI.ResetOnSpawn = false
GUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
GUI.Parent = CoreGui

local WarnLabel = Instance.new("TextLabel", GUI)
WarnLabel.Text = "‚ö†Ô∏èYou are visible‚ö†Ô∏è"
WarnLabel.Visible = false
WarnLabel.Size = UDim2.new(0, 200, 0, 30)
WarnLabel.Position = UDim2.new(0.5, -100, 0.85, 0)
WarnLabel.BackgroundTransparency = 1
WarnLabel.Font = Enum.Font.GothamSemibold
WarnLabel.TextSize = 24
WarnLabel.TextColor3 = Color3.fromRGB(255,255,0)
WarnLabel.TextStrokeTransparency = 0.5
WarnLabel.ZIndex = 10

local function Grounded()
    return Humanoid and Humanoid:IsDescendantOf(workspace) and Humanoid.FloorMaterial ~= Enum.Material.Air
end

local function LoadAndPrepareTrack()
    if Track then
        pcall(function() Track:Stop() end)
        Track = nil
    end
    if Humanoid then
        local ok, res = pcall(function() return Humanoid:LoadAnimation(Animation) end)
        if ok and res then
            Track = res
            Track.Priority = Enum.AnimationPriority.Action4
        else
            Track = nil
        end
    else
        Track = nil
    end
end

local function Invis_Disable()
    if not InvisEnabled then return end
    InvisEnabled = false
    if Track then pcall(function() Track:Stop() end) end
    if Humanoid then pcall(function() workspace.CurrentCamera.CameraSubject = Humanoid end) end
    if Character then
        for _, v in pairs(Character:GetDescendants()) do
            if v:IsA("BasePart") and v.Transparency == 0.5 then
                v.Transparency = 0
            end
        end
    end
    WarnLabel.Visible = false
end

local function Invis_Enable()
    if InvisEnabled or not Invis_Fixed then return end
    UpdateCharacterReferences()
    if not Character or not Humanoid or not HumanoidRootPart then return end
    if not Character:FindFirstChild("Torso") then
        pcall(function()
            StarterGui:SetCore("SendNotification", {Title="Invisibility FAILED", Text="Feature requires R6 Avatar.", Duration=5})
        end)
        return
    end
    InvisEnabled = true
    pcall(function() workspace.CurrentCamera.CameraSubject = HumanoidRootPart end)
    LoadAndPrepareTrack()
end

-- Conex√µes de troca de character
Player.CharacterAdded:Connect(function(newChar)
    if Track then pcall(function() Track:Stop() end) Track = nil end
    task.wait()
    UpdateCharacterReferences()
    if not Humanoid then
        task.wait(0.5)
        UpdateCharacterReferences()
        if not Humanoid then
            Invis_Fixed = false
            if InvisEnabled then Invis_Disable() end
            pcall(function()
                StarterGui:SetCore("SendNotification", {Title="Invisibility Error", Text="Could not verify character type.", Duration=5})
            end)
            return
        end
    end
    if Humanoid.RigType ~= Enum.HumanoidRigType.R6 then
        Invis_Fixed = false
        if InvisEnabled then Invis_Disable() end
        pcall(function()
            StarterGui:SetCore("SendNotification", {Title="Invisibility Warning", Text="Non-R6 Avatar detected. Invisibility disabled.", Duration=5})
        end)
        return
    else
        Invis_Fixed = true
    end
    if InvisEnabled then
        if HumanoidRootPart then pcall(function() workspace.CurrentCamera.CameraSubject = HumanoidRootPart end) end
        LoadAndPrepareTrack()
    end
end)

Player.CharacterRemoving:Connect(function()
    if Track then pcall(function() Track:Stop() end) Track = nil end
    WarnLabel.Visible = false
end)

-- Loop principal (uso de Heartbeat)
if Heartbeat then
    Heartbeat:Connect(function(deltaTime)
        if not InvisEnabled or not Invis_Fixed then
            if not InvisEnabled and Character then
                for _, v in pairs(Character:GetDescendants()) do
                    if v:IsA("BasePart") and v.Transparency == 0.5 then v.Transparency = 0 end
                end
            end
            WarnLabel.Visible = false
            return
        end

        if not Character or not Humanoid or not HumanoidRootPart or not Humanoid:IsDescendantOf(workspace) or Humanoid.Health <= 0 then
            WarnLabel.Visible = false
            return
        end

        WarnLabel.Visible = not Grounded()

        local speed = 12
        if Humanoid.MoveDirection.Magnitude > 0 then
            local offset = Humanoid.MoveDirection * speed * deltaTime
            if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
                HumanoidRootPart.CFrame = HumanoidRootPart.CFrame + offset
            end
        end

        local OldCFrame = HumanoidRootPart.CFrame
        local OldCameraOffset = Humanoid.CameraOffset

        local _, y = workspace.CurrentCamera.CFrame:ToOrientation()
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
            HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.CFrame.Position) * CFrame.fromOrientation(0, y, 0)
            HumanoidRootPart.CFrame = HumanoidRootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0)
        end
        Humanoid.CameraOffset = Vector3.new(0, 1.44, 0)

        if Track then
            local ok = pcall(function()
                if not Track.IsPlaying then Track:Play() end
                Track:AdjustSpeed(0)
                Track.TimePosition = 0.3
            end)
            if not ok then LoadAndPrepareTrack() end
        elseif Humanoid and Humanoid.Health > 0 then
            LoadAndPrepareTrack()
        end

        if RenderStepped then RenderStepped:Wait() end

        if Humanoid and Humanoid:IsDescendantOf(workspace) then
            Humanoid.CameraOffset = OldCameraOffset
        end
        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
            HumanoidRootPart.CFrame = OldCFrame
        end

        if Track then pcall(function() Track:Stop() end) end

        if HumanoidRootPart and HumanoidRootPart:IsDescendantOf(workspace) then
            local LookVector = workspace.CurrentCamera.CFrame.LookVector
            local Horizontal = Vector3.new(LookVector.X, 0, LookVector.Z)
            if Horizontal.Magnitude > 0.1 then
                local TargetCFrame = CFrame.new(HumanoidRootPart.Position, HumanoidRootPart.Position + Horizontal.Unit)
                HumanoidRootPart.CFrame = TargetCFrame
            end
        end

        if Character then
            for _, v in pairs(Character:GetDescendants()) do
                if v:IsA("BasePart") and v.Transparency ~= 1 then
                    v.Transparency = 0.5
                end
            end
        end
    end)
end

-- Expondo fun√ß√µes com prote√ß√£o
_G.Invis_Enable = Invis_Enable
_G.Invis_Disable = Invis_Disable
_G.IsInvisEnabled = function() return InvisEnabled end

-- === Toggle (UI) segura: chama as fun√ß√µes por pcall para evitar erros no runtime ===
plrc:AddToggle("inv", {
    Text = "Invisible",
    Tooltip = "This is a tooltip",
    DisabledTooltip = "I am disabled!",
    Default = false,
    Disabled = false,
    Visible = true,
    Risky = false,

    Callback = function(Value)
        functions.invisible = Value
        if Value then
            pcall(function() if _G and _G.Invis_Enable then _G.Invis_Enable() end end)
        else
            pcall(function() if _G and _G.Invis_Disable then _G.Invis_Disable() end end)
        end
    end
})



local rp = game:GetService("ReplicatedStorage")
local ts = rp:FindFirstChild("Values") and rp.Values:FindFirstChild("FinishSpeedMulti")
if ts then
    plrc:AddSlider("finish", {
        Text = "Finish Stomp Speed",
        Default = 2,
        Min = 0,
        Max = 10,
        Rounding = 1,
        Compact = false,
        
        Callback = function(Value)
            ts.Value = Value 
        end,
        
        Tooltip = "I am a slider!", -- Information shown when you hover over the slider
        DisabledTooltip = "I am disabled!", -- Information shown when you hover over the slider while it's disabled
        
        Disabled = false, -- Will disable the slider (true / false)
        Visible = true, -- Will make the slider invisible (true / false)
        })
end
